<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unglish Word Generator Demo</title>
    <style>
        :root {
            --bg: white;
            --fg: black;
            --muted: gray;
            --card-border: silver;
            --card-bg: whitesmoke;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: black;
                --fg: white;
                --muted: darkgray;
                --card-border: dimgray;
                --card-bg: #111;
            }
        }

        body {
            font-family: ui-serif, Georgia, serif;
            background: var(--bg);
            color: var(--fg);
            max-width: 42em;
            margin: 0 auto;
            padding: 2em 1em;
        }

        header { text-align: center; }
        header p { color: var(--muted); font-style: italic; }

        /* Tabs — plain unstyled buttons */
        .tab-bar { display: flex; gap: 0.5em; margin-bottom: 1em; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Cards */
        .card {
            border: 1px solid var(--card-border);
            border-radius: 4px;
            padding: 1em 1.25em;
            margin: 1em 0;
            background: var(--card-bg);
            position: relative;
        }
        .card h2 {
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--muted);
        }

        /* Refresh buttons — using U+21BB clockwise open circle arrow */
        .refresh {
            position: absolute;
            top: 0.75em;
            right: 0.75em;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1em;
            color: var(--muted);
            line-height: 1;
        }
        .refresh:hover { color: var(--fg); }
        .page-btn { padding: 0.2em 0.6em; border: 1px solid var(--muted); background: var(--bg); color: var(--fg); cursor: pointer; font-size: 0.85em; }
        .page-btn:hover:not(:disabled) { background: var(--muted); color: var(--bg); }
        .page-btn:disabled { opacity: 0.4; cursor: default; }

        /* Single word */
        .single-written { font-size: 2em; font-weight: 700; }
        .pronunciation { font-family: monospace; color: var(--muted); }

        /* Haiku */
        .haiku-written { font-size: 1.2em; }
        .haiku-ipa { font-family: monospace; color: var(--muted); font-size: 0.85em; }

        /* Slogan */
        .slogan-text { font-size: 1.3em; font-weight: 600; text-transform: capitalize; }

        /* Stat line */
        .stat-line { font-style: italic; color: var(--muted); font-size: 0.85em; }

        /* Lexicon placeholder */
        .placeholder { color: var(--muted); font-style: italic; padding: 3em 0; text-align: center; }

        /* Word wall */
        .word-wall { line-height: 2.2; }
        .word-pill {
            display: inline-block;
            padding: 0.15em 0.5em;
            margin: 0.1em 0.15em;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .syl-1 { background: gainsboro; color: black; }
        .syl-2 { background: darkgray; color: black; }
        .syl-3 { background: gray; color: white; }
        .syl-4 { background: dimgray; color: white; }
        .legend { font-size: 0.8em; color: var(--muted); margin-top: 0.5em; }
        .legend span { margin-right: 1em; }

        /* Horizontal bar charts */
        .bar-chart { margin: 0.5em 0; }
        .bar-row { display: flex; align-items: center; margin: 0.2em 0; font-size: 0.85em; }
        .bar-label { width: 3.5em; text-align: right; padding-right: 0.5em; flex-shrink: 0; }
        .bar-track { flex: 1; background: var(--card-bg); height: 1.2em; position: relative; border: 1px solid var(--card-border); }
        .bar-fill { height: 100%; display: inline-block; vertical-align: top; }
        .bar-value { font-size: 0.8em; color: var(--muted); padding-left: 0.4em; white-space: nowrap; flex-shrink: 0; }

        /* Frequency comparison */
        .freq-row { display: flex; align-items: center; margin: 0.15em 0; font-size: 0.8em; }
        .freq-letter { width: 1.5em; text-align: right; padding-right: 0.4em; font-weight: bold; flex-shrink: 0; }
        .freq-bars { flex: 1; }
        .freq-bar { height: 0.6em; display: block; margin: 1px 0; }
        .freq-unglish { background: dimgray; }
        .freq-english { background: silver; }
        .freq-val { font-size: 0.75em; color: var(--muted); padding-left: 0.3em; flex-shrink: 0; width: 7em; }
        .freq-val .dev-over { color: #c44; }
        .freq-val .dev-under { color: #48a; }


        /* Common words race */
        .cw-pill {
            display: inline-block;
            padding: 0.15em 0.5em;
            margin: 0.1em;
            border-radius: 3px;
            font-size: 0.85em;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            color: var(--muted);
            transition: all 0.3s;
        }
        .cw-pill.found { background: dimgray; color: white; border-color: dimgray; }
        .cw-status { font-size: 0.85em; color: var(--muted); margin-top: 0.5em; }

        /* Pick the Real Word game */
        .real-btn {
            display: inline-block;
            width: 48%;
            text-align: center;
            font: inherit;
            font-size: 1.1em;
            padding: 0.6em 0.75em;
            margin: 0.3em 1%;
            cursor: pointer;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            color: var(--fg);
            border-radius: 3px;
        }
        .real-btn:hover { border-color: var(--fg); }
        .real-btn.correct { background: darkgray; color: white; border-color: darkgray; }
        .real-btn.wrong { background: var(--card-bg); border-color: var(--fg); text-decoration: line-through; }
        .real-btn.revealed { cursor: default; }
        .real-btn.correct.revealed { opacity: 1; }
        .real-btn.wrong.revealed { opacity: 0.5; }
        .game-score { font-weight: bold; margin-bottom: 0.5em; }
        .game-actions { margin-top: 0.75em; }
        .game-actions button {
            font: inherit;
            padding: 0.4em 1em;
            cursor: pointer;
            background: dimgray;
            color: white;
            border: none;
            border-radius: 3px;
            margin-right: 0.5em;
        }
        .game-actions button:hover { background: gray; }
        .start-btn {
            font: inherit;
            padding: 0.4em 1em;
            cursor: pointer;
            background: dimgray;
            color: white;
            border: none;
            border-radius: 3px;
        }
        .start-btn:hover { background: gray; }
        .ref-line { font-size: 0.8em; color: var(--muted); font-style: italic; margin-top: 0.3em; }

        .sort-btn { padding: 0.2em 0.7em; border: 1px solid var(--muted); background: var(--bg); color: var(--fg); cursor: pointer; font-size: 0.9em; border-radius: 3px; }
        .sort-btn:hover:not(.active) { background: var(--muted); color: var(--bg); }
        .sort-btn.active { background: var(--fg); color: var(--bg); }

        /* Debug workbench */
        .debug-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6em;
            align-items: center;
            margin: 0 0 1em 0;
            font-size: 0.85em;
            color: var(--muted);
        }
        .debug-controls input, .debug-controls select, .debug-controls button {
            font: inherit;
        }
        .debug-controls button {
            border: 1px solid var(--muted);
            background: var(--bg);
            color: var(--fg);
            padding: 0.25em 0.65em;
            border-radius: 3px;
            cursor: pointer;
        }
        .debug-controls button:hover:not(:disabled) {
            background: var(--muted);
            color: var(--bg);
        }
        .debug-word {
            font-size: 2.4em;
            font-weight: 700;
            letter-spacing: 0.02em;
            line-height: 1.2;
            margin-bottom: 0.2em;
            user-select: none;
        }
        .debug-char {
            display: inline-block;
            padding: 0 0.03em;
            border-radius: 0.15em;
            cursor: pointer;
        }
        .debug-char.active {
            background: #222;
            color: #fff;
        }
        .debug-char.selected {
            outline: 2px solid var(--fg);
            outline-offset: 1px;
        }
        .debug-layer { margin: 0.65em 0; }
        .debug-layer-title {
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--muted);
            margin-bottom: 0.35em;
        }
        .debug-token {
            display: inline-block;
            margin: 0.12em 0.2em 0.12em 0;
            padding: 0.18em 0.44em;
            border: 1px solid var(--card-border);
            border-radius: 3px;
            font-size: 0.88em;
            cursor: pointer;
            user-select: none;
        }
        .debug-token:hover { border-color: var(--fg); }
        .debug-token.active {
            background: #222;
            color: #fff;
            border-color: #222;
        }
        .debug-token.selected {
            outline: 1px dashed var(--fg);
            outline-offset: 1px;
        }
        .debug-grid {
            display: grid;
            gap: 0.8em;
        }
        .debug-trace-list {
            border: 1px solid var(--card-border);
            border-radius: 3px;
            max-height: 14em;
            overflow: auto;
            background: var(--bg);
        }
        .debug-trace-row {
            padding: 0.35em 0.45em;
            border-bottom: 1px solid var(--card-border);
            font-size: 0.82em;
            font-family: ui-monospace, Menlo, monospace;
            line-height: 1.35;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .debug-trace-row:last-child { border-bottom: 0; }
        .debug-trace-row.active {
            background: #222;
            color: #fff;
        }
        .debug-trace-row.selected {
            outline: 2px solid var(--fg);
            outline-offset: -2px;
        }
        .debug-selected {
            font-size: 0.82em;
            color: var(--muted);
            margin-top: 0.45em;
            white-space: pre-wrap;
        }
        .debug-comment {
            width: 100%;
            min-height: 5em;
            font: inherit;
            font-size: 0.88em;
            border: 1px solid var(--card-border);
            border-radius: 3px;
            background: var(--bg);
            color: var(--fg);
            padding: 0.5em;
            box-sizing: border-box;
        }
        .debug-copy-actions {
            display: flex;
            gap: 0.5em;
            margin-top: 0.55em;
        }
        .debug-status {
            font-size: 0.8em;
            color: var(--muted);
            margin-top: 0.35em;
            min-height: 1.2em;
        }
        .debug-hint {
            font-size: 0.8em;
            color: var(--muted);
            margin: 0.35em 0 0.6em 0;
        }
    </style>
    <script src="cmuBaselines.js"></script>
    <script type="module">
        import unglish, { generateWords } from '../dist/index.js';
        import { realWords } from './realwords.js';

        const BUILD_INFO = '__BUILD_INFO__'; // Replaced during build

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        function init() {
            const $ = id => document.getElementById(id);
            
            // Display build info
            $('build-info').textContent = BUILD_INFO;

            const morphToggle = $('morph-toggle');
            const useMorph = () => morphToggle.checked;

            let currentWord = '';
            function genSingleWord() {
                const w = unglish.generateWord({ mode: 'text', morphology: useMorph() });
                currentWord = w.written.clean;
                $('single-written').textContent = currentWord;
                $('single-ipa').textContent = w.pronunciation;
            }

            function speakWord() {
                if (!currentWord || !window.speechSynthesis) return;
                const utt = new SpeechSynthesisUtterance(currentWord);
                utt.lang = 'en-GB';
                utt.rate = 0.85;
                speechSynthesis.speak(utt);
            }

            function genHaiku() {
                const patterns = [[2,2,1],[3,2,2],[2,1,2]];
                const lines = patterns.map(p => p.map(n => unglish.generateWord({ syllableCount: n, mode: 'text', morphology: useMorph() })));
                $('haiku-written').innerHTML = lines.map(l => l.map(w => w.written.clean).join(' ')).join('<br>');
                $('haiku-ipa').innerHTML = lines.map(l => l.map(w => w.pronunciation).join(' ')).join('<br>');
            }

            const firstWords = [
                "Ignore Haters \u2014", "Always", "Just", "Never", "Forever", "Never Quit \u2014",
                "Passionately", "Fearlessly", "Endlessly", "Forget Fear \u2014",
                "You Can", "Relentlessly",
            ];
            const lastWords = [
                "It", "Your Dreams", "Success", "Your Enemies", "Fear", "Love", "Tomorrow",
                "Yourself", "The Future", "Greatness", "Excellence", "Possibilities",
                "Potential", "Destiny", "The World", "Your Goals", "Perfection",
                "Innovation", "Happiness", "Victory", "Hard Things"
            ];
            const pick = arr => arr[Math.floor(Math.random() * arr.length)];
            const randInt = (a, b) => a + Math.floor(Math.random() * (b - a + 1));

            function genSlogan() {
                const w = unglish.generateWord({ syllableCount: 1, mode: 'text', morphology: useMorph() });
                $('slogan-text').textContent = `${pick(firstWords)} ${w.written.clean} ${pick(lastWords)}`;
            }

            // Sentence templates — slots: W=any word, N=noun-like(2-3syl), V=verb-like(1syl), A=adj-like(2syl)
            const templates = [
                'The W of W',
                'W and W W the W',
                'A W W the W',
                'The W W, but the W W',
                'W W the W of W',
                'It W the W',
                'W W, W W',
                'The W W W',
                'W the W and W',
                'No W W without W',
                'Every W W a W',
                'W W; the W W',
                'Some W W the W of W',
                'W W the W, then W',
                'A W of W and W',
                'Was it W or W?',
                'The W W W the W',
            ];

            function genFromTemplate() {
                const tmpl = pick(templates);
                const allWords = [];
                const text = tmpl.replace(/W/g, () => {
                    const w = unglish.generateWord({ mode: 'text', morphology: useMorph() });
                    allWords.push(w);
                    return w.written.clean;
                });
                // Capitalize first letter
                const capped = text.charAt(0).toUpperCase() + text.slice(1);
                // Add terminal punctuation (already has ? if template includes it)
                const final = capped.endsWith('?') ? capped : capped + '.';
                return { text: final, words: allWords };
            }

            function makeSentence() {
                return genFromTemplate();
            }

            function genSentence() {
                const s = makeSentence();
                $('sentence-text').textContent = s.text;
            }

            function genParagraph() {
                const allWords = [];
                const paragraphs = [];
                for (let p = 0; p < 2; p++) {
                    const sentences = [];
                    const count = randInt(3, 5);
                    for (let i = 0; i < count; i++) {
                        const s = makeSentence();
                        sentences.push(s.text);
                        allWords.push(...s.words);
                    }
                    paragraphs.push(sentences.join(' '));
                }
                $('paragraph-text').innerHTML = paragraphs.map(p => `<p>${p}</p>`).join('');

                const mono = allWords.filter(w => w.syllables.length === 1).length;
                const monoPct = ((mono / allWords.length) * 100).toFixed(1);
                const avgLen = (allWords.reduce((s, w) => s + w.written.clean.length, 0) / allWords.length).toFixed(1);
                $('paragraph-stats').textContent = `${allWords.length} words \u00b7 ${monoPct}% monosyllabic \u00b7 avg ${avgLen} letters`;
            }

            // --- Tab switching ---
            document.querySelectorAll('.tab-bar button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-bar button').forEach(b => b.disabled = false);
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    btn.disabled = true;
                    $(btn.dataset.tab).classList.add('active');
                });
            });

            $('refresh-single').addEventListener('click', genSingleWord);
            $('speak-single').addEventListener('click', speakWord);
            $('refresh-haiku').addEventListener('click', genHaiku);
            $('refresh-slogan').addEventListener('click', genSlogan);
            $('refresh-sentence').addEventListener('click', genSentence);
            $('refresh-paragraph').addEventListener('click', genParagraph);

            // ===== LEXICON TAB =====

            const sylColors = ['syl-1','syl-2','syl-3','syl-4'];
            const sylLabels = ['1 syl','2 syl','3 syl','4+ syl'];
            const sylBgNames = ['gainsboro','darkgray','gray','dimgray'];

            let lexWords = [];

            function genWordWall() {
                lexWords = generateWords(200, { mode: 'lexicon', morphology: useMorph() });
                const wall = $('word-wall');
                wall.innerHTML = '';
                lexWords.forEach(w => {
                    const sp = document.createElement('span');
                    const sc = Math.min(w.syllables.length, 4);
                    sp.className = 'word-pill ' + sylColors[sc - 1];
                    sp.textContent = w.written.clean;
                    sp.title = w.pronunciation + ' (' + sc + ' syl)';
                    wall.appendChild(sp);
                });
                // legend
                $('wall-legend').innerHTML = sylLabels.map((l,i) =>
                    '<span><span class="word-pill ' + sylColors[i] + '">' + l + '</span></span>'
                ).join('');
            }

                        // Common words race
            let cwWorker = null;
            $('cw-start').addEventListener('click', function() {
                this.disabled = true;
                $('cw-pills').innerHTML = '';
                $('cw-status').textContent = 'Starting...';
                if (cwWorker) cwWorker.terminate();
                cwWorker = new Worker('commonWordsWorker.js');
                cwWorker.onmessage = function(e) {
                    if (e.data.type === 'wordList') {
                        $('cw-pills').innerHTML = e.data.words.map(w => '<span class="cw-pill" id="cw-' + w + '">' + w + '</span>').join('');
                    } else if (e.data.type === 'wordFound') {
                        const pill = document.getElementById('cw-' + e.data.word);
                        if (pill) pill.classList.add('found');
                        $('cw-status').textContent = (100 - e.data.remainingCount) + '/100 found · ' + e.data.iterations.toLocaleString() + ' generated · ' + e.data.time + 's';
                    } else if (e.data.type === 'progress') {
                        $('cw-status').textContent = e.data.foundCount + '/100 found · ' + e.data.iterations.toLocaleString() + ' generated...';
                    } else if (e.data.type === 'complete') {
                        const unique = e.data.uniqueCount || e.data.iterations;
                        const uniquePct = ((unique / e.data.iterations) * 100).toFixed(1);
                        $('cw-status').textContent = 'All 100 found in ' + e.data.iterations.toLocaleString() + ' generations (' + e.data.duration + 's) \u00b7 ' + unique.toLocaleString() + ' unique (' + uniquePct + '%)';
                        $('cw-start').disabled = false;
                        cwWorker.terminate();
                        cwWorker = null;
                    }
                };
                cwWorker.postMessage({ action: 'findCommonWords' });
            });

            // "Pick the Real Word" game — 2 choices, one real, one generated
            let gameRound = 0, gameCorrect = 0, gamePlayed = 0;
            const usedRealWords = new Set();

            function shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }

            function pickUnusedReal() {
                let word;
                do { word = realWords[Math.floor(Math.random() * realWords.length)]; } while (usedRealWords.has(word));
                usedRealWords.add(word);
                return word;
            }

            function newGameRound() {
                gameRound = 0; gameCorrect = 0; gamePlayed = 0;
                $('game-score').textContent = '';
                $('game-actions').innerHTML = '';
                showNextPair();
            }

            function showNextPair() {
                const real = pickUnusedReal();
                const fake = unglish.generateWord({ mode: 'lexicon', morphology: useMorph() }).written.clean;
                const pair = shuffle([{word: real, real: true}, {word: fake, real: false}]);
                gameRound++;

                $('game-words').innerHTML = '<p style="color:var(--muted);font-size:0.85em">Round ' + gameRound + ' \u2014 Pick the real English word:</p>' +
                    pair.map((p, i) =>
                        '<button class="real-btn" data-idx="' + i + '">' + p.word + '</button>'
                    ).join(' ');

                document.querySelectorAll('.real-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        if (this.classList.contains('revealed')) return;
                        const idx = parseInt(this.dataset.idx);
                        const picked = pair[idx];
                        const other = pair[1 - idx];
                        gamePlayed++;
                        if (picked.real) gameCorrect++;

                        // Reveal both
                        document.querySelectorAll('.real-btn').forEach((b, bi) => {
                            b.classList.add('revealed');
                            const p = pair[bi];
                            b.classList.add(p.real ? 'correct' : 'wrong');
                            b.innerHTML = p.word + ' <span style="font-size:0.75em;opacity:0.7">' + (p.real ? '\u2713 real' : '\u2717 fake') + '</span>';
                        });

                        $('game-score').textContent = gameCorrect + '/' + gamePlayed + ' correct';

                        if (gamePlayed >= 10) {
                            const pct = (gameCorrect / 10 * 100);
                            const verdict = pct >= 90 ? 'Suspicious. Are you a dictionary?' :
                                            pct >= 70 ? 'Sharp eye.' :
                                            pct >= 50 ? 'Not bad \u2014 the generator fooled you a few times.' :
                                            'The generator wins this round.';
                            $('game-actions').innerHTML = '<p style="margin:0.5em 0"><strong>' + gameCorrect + '/10</strong> \u2014 ' + verdict + '</p>' +
                                '<button class="start-btn" id="game-new">Play Again</button>';
                            $('game-new').addEventListener('click', newGameRound);
                        } else {
                            $('game-actions').innerHTML = '<button class="start-btn" id="game-next">Next \u2192</button>';
                            $('game-next').addEventListener('click', showNextPair);
                        }
                    });
                });
            }

            $('refresh-wall').addEventListener('click', () => { genWordWall(); });

            // Init lexicon on first tab switch (lazy) or immediately if active
            let lexiconInited = false;
            function initLexicon() {
                if (lexiconInited) return;
                lexiconInited = true;
                genWordWall();
                newGameRound();
            }

            // ===== STATS TAB =====

            // CMU Pronouncing Dictionary baselines (unique words, lexicon mode)
            const engLetterFreq = {e:11.46,a:8.80,r:7.76,i:7.65,n:7.28,s:6.92,o:6.42,t:5.85,l:5.83,c:3.91,d:3.52,m:3.11,u:3.07,h:2.88,g:2.77,p:2.29,b:2.25,k:1.80,y:1.60,f:1.39,w:1.10,v:1.05,z:0.65,j:0.26,x:0.23,q:0.14};
            const engLengthDist = {1:0,2:0.2,3:1.3,4:5.2,5:11.5,6:17.4,7:18.6,8:15.5,9:11.7,10:8.1,11:4.8,12:2.7,13:2.4};

            function pearsonR(xs, ys) {
                const n = xs.length;
                const mx = xs.reduce((a,b) => a+b, 0) / n;
                const my = ys.reduce((a,b) => a+b, 0) / n;
                let num = 0, dx2 = 0, dy2 = 0;
                for (let i = 0; i < n; i++) {
                    const dx = xs[i] - mx, dy = ys[i] - my;
                    num += dx * dy; dx2 += dx * dx; dy2 += dy * dy;
                }
                return num / Math.sqrt(dx2 * dy2);
            }

            let statsWorker = null;
            let statsInited = false;
            let chartData = null;

            function sortItems(items, mode) {
                const sorted = [...items];
                if (mode === 'divergence') {
                    sorted.sort((a, b) => {
                        const devOf = (x) => {
                            if (x.eng === null) return -1;
                            if (x.eng <= 0) return x.gen > 0 ? Infinity : 0;
                            const r = x.gen / x.eng;
                            return r >= 1 ? r - 1 : (1 / r) - 1; // symmetric: 2× and 0.5× both score 1.0
                        };
                        return devOf(b) - devOf(a);
                    });
                } else if (mode === 'english') {
                    sorted.sort((a, b) => (b.eng ?? -Infinity) - (a.eng ?? -Infinity));
                } else { // unglish
                    sorted.sort((a, b) => b.gen - a.gen);
                }
                return sorted;
            }

            function rerenderCharts(mode) {
                if (!chartData) return;
                renderPaginatedChart('stats-letter-chart', 'stats-letter-pager', sortItems(chartData.letterItems, mode), 15, '1.5em', 1, mode);
                renderPaginatedChart('stats-bigram-chart', 'stats-bigram-pager', sortItems(chartData.bigramItems, mode), 5, '2.5em', 2, mode);
                renderPaginatedChart('stats-trigram-chart', 'stats-trigram-pager', sortItems(chartData.trigramItems, mode), 2, '2.5em', 2, mode);
                if (chartData.phonemeItems.length > 0) {
                    renderPaginatedChart('stats-phoneme-chart', 'stats-phoneme-pager', sortItems(chartData.phonemeItems, mode), 10, '2.5em', 2, mode);
                }
            }

            function normalizePhonemeForStats(sound) {
                if (!sound || typeof sound !== 'string') return null;
                let normalized = sound.replace(/\u02B0/g, '');
                const aliasMap = phonemeNormalization?.generatedAliases || {};
                if (aliasMap[normalized]) normalized = aliasMap[normalized];
                return normalized;
            }

            function runStats() {
                const countInput = parseInt(($('stats-sample-size')?.value || '200000'), 10);
                const seedInput = parseInt(($('stats-seed-start')?.value || ''), 10);
                const diagnosticsEnabled = !!$('stats-enable-diagnostics')?.checked;
                const traceSamplePercent = parseFloat(($('stats-trace-sample')?.value || '0'));
                const count = Number.isFinite(countInput) && countInput > 0 ? countInput : 200000;
                const seedStart = Number.isFinite(seedInput) ? seedInput : null;
                const safeTraceSample = Number.isFinite(traceSamplePercent) && traceSamplePercent >= 0 ? traceSamplePercent : 0;

                $('stats-status').textContent = 'Generating ' + count.toLocaleString() + ' words...';
                if (statsWorker) statsWorker.terminate();
                statsWorker = new Worker('statsWorker.js?v=' + Date.now());
                statsWorker.onmessage = function(ev) {
                    if (ev.data.type === 'progress') {
                        $('stats-status').textContent = 'Generating ' + ev.data.total.toLocaleString() + ' words... ' + ev.data.done.toLocaleString() + '/' + ev.data.total.toLocaleString();
                    } else if (ev.data.type === 'stats') {
                        renderStats(ev.data.words, ev.data.phonemes, ev.data.diagnostics || null);
                        statsWorker.terminate();
                        statsWorker = null;
                    }
                };
                statsWorker.postMessage({
                    action: 'generateStats',
                    count,
                    seedStart,
                    diagnostics: {
                        enabled: diagnosticsEnabled,
                        traceSamplePercent: safeTraceSample,
                    },
                });
            }

            // Paginated chart helper
            const PAGE_SIZE = 50;
            const legendHtml = '<span style="display:inline-block;width:0.8em;height:0.8em;background:steelblue;vertical-align:middle"></span> Generated &nbsp; <span style="display:inline-block;width:0.8em;height:0.8em;background:darkgrey;vertical-align:middle"></span> CMU Dictionary';

            function renderPaginatedChart(chartId, pagerId, items, maxPct, labelWidth, decimals, sortMode) {
                // items: [{key, gen, eng}] sorted by gen desc
                let page = 0;
                const totalPages = Math.ceil(items.length / PAGE_SIZE);

                function fmtDev(item) {
                    if (item.eng === null) return '';
                    if (item.eng <= 0) return item.gen > 0 ? '<span class="dev-over">∞</span>' : '=';
                    const ratio = item.gen / item.eng;
                    if (Math.abs(ratio - 1) < 0.005) return '≈1×';
                    const arrow = ratio > 1 ? '↑' : '↓';
                    const cls = ratio > 1 ? 'dev-over' : 'dev-under';
                    return '<span class="' + cls + '">' + arrow + ratio.toFixed(2) + '×</span>';
                }

                function renderPage() {
                    const start = page * PAGE_SIZE;
                    const slice = items.slice(start, start + PAGE_SIZE);
                    $(chartId).innerHTML = slice.map(item => {
                        const wG = (item.gen / maxPct * 100).toFixed(1);
                        const wE = item.eng !== null ? (item.eng / maxPct * 100).toFixed(1) : '0';
                        const engStr = item.eng !== null ? item.eng.toFixed(decimals) : '—';
                        const valStr = sortMode === 'divergence' ? fmtDev(item) : item.gen.toFixed(decimals) + ' / ' + engStr;
                        return '<div class="freq-row"><div class="freq-letter" style="width:' + labelWidth + '">' + item.label + '</div><div class="freq-bars">' +
                            '<div class="freq-bar" style="width:' + wG + '%;background:steelblue"></div>' +
                            (item.eng !== null ? '<div class="freq-bar" style="width:' + wE + '%;background:darkgrey"></div>' : '') +
                            '</div><div class="freq-val">' + valStr + '</div></div>';
                    }).join('');

                    if (totalPages > 1) {
                        $(pagerId).innerHTML = '<div style="display:flex;align-items:center;gap:0.5em;margin:0.5em 0;font-size:0.85em">' +
                            '<button ' + (page === 0 ? 'disabled' : '') + ' class="page-btn" data-dir="-1">← Prev</button>' +
                            '<span>Page ' + (page + 1) + ' of ' + totalPages + ' (' + items.length + ' total)</span>' +
                            '<button ' + (page >= totalPages - 1 ? 'disabled' : '') + ' class="page-btn" data-dir="1">Next →</button></div>';
                        $(pagerId).querySelectorAll('.page-btn').forEach(btn => {
                            btn.addEventListener('click', () => { page += parseInt(btn.dataset.dir); renderPage(); });
                        });
                    } else {
                        $(pagerId).innerHTML = '<div style="font-size:0.85em;color:var(--muted);margin:0.3em 0">' + items.length + ' entries</div>';
                    }
                }
                renderPage();
            }

            function renderStats(words, phonemeData, diagnostics) {
                $('stats-status').textContent = words.length.toLocaleString() + ' words generated.';
                if (diagnostics && diagnostics.enabled) {
                    const structural = Object.entries(diagnostics.structuralEventCounts || {}).sort((a, b) => b[1] - a[1]).slice(0, 5);
                    const repairs = Object.entries(diagnostics.repairRuleCounts || {}).sort((a, b) => b[1] - a[1]).slice(0, 5);
                    const morphology = Object.entries(diagnostics.morphologyTemplateCounts || {}).sort((a, b) => b[1] - a[1]).slice(0, 5);
                    $('stats-diagnostics').innerHTML =
                        '<div style="font-size:0.85em;color:var(--muted);margin-bottom:0.4em">Trace diagnostics sampled ' +
                        diagnostics.tracedWords.toLocaleString() + '/' + diagnostics.totalWords.toLocaleString() +
                        ' words (' + diagnostics.traceSamplePercent + '%).</div>' +
                        '<div style="font-size:0.85em"><strong>Structural events:</strong> ' + (structural.map(([k, v]) => k + ' (' + v + ')').join(', ') || 'none') + '</div>' +
                        '<div style="font-size:0.85em"><strong>Repair rules:</strong> ' + (repairs.map(([k, v]) => k + ' (' + v + ')').join(', ') || 'none') + '</div>' +
                        '<div style="font-size:0.85em"><strong>Morphology templates:</strong> ' + (morphology.map(([k, v]) => k + ' (' + v + ')').join(', ') || 'none') + '</div>';
                } else {
                    $('stats-diagnostics').innerHTML = '<div style="font-size:0.85em;color:var(--muted)">Diagnostics disabled (default).</div>';
                }

                // Letter frequency (always 26)
                const letterCounts = {};
                let totalLetters = 0;
                for (const w of words) {
                    for (const ch of w.toLowerCase()) {
                        if (ch >= 'a' && ch <= 'z') { letterCounts[ch] = (letterCounts[ch] || 0) + 1; totalLetters++; }
                    }
                }
                const letterItems = Object.keys(engLetterFreq)
                    .map(ch => ({ key: ch, label: ch.toUpperCase(), gen: totalLetters ? (letterCounts[ch] || 0) / totalLetters * 100 : 0, eng: engLetterFreq[ch] }))
                    .sort((a, b) => b.gen - a.gen);
                const letterGenPcts = letterItems.map(x => x.gen);
                const letterEngPcts = letterItems.map(x => x.eng);
                $('stats-letter-r').textContent = 'Pearson r = ' + pearsonR(letterGenPcts, letterEngPcts).toFixed(4);
                $('stats-letter-legend').innerHTML = legendHtml;

                // Bigram frequency — all generated bigrams
                const bigramCounts = {};
                let totalBigrams = 0;
                for (const w of words) {
                    const lw = w.toLowerCase();
                    for (let i = 0; i < lw.length - 1; i++) {
                        const bg = lw[i] + lw[i+1];
                        if (bg[0] >= 'a' && bg[0] <= 'z' && bg[1] >= 'a' && bg[1] <= 'z') {
                            bigramCounts[bg] = (bigramCounts[bg] || 0) + 1; totalBigrams++;
                        }
                    }
                }
                const bigramItems = Object.entries(bigramCounts)
                    .map(([bg, c]) => ({ key: bg, label: bg.toUpperCase(), gen: c / totalBigrams * 100, eng: cmuBigrams[bg] ?? null }))
                    .sort((a, b) => b.gen - a.gen);
                // Pearson r on shared keys only
                const sharedBi = bigramItems.filter(x => x.eng !== null);
                if (sharedBi.length > 1) $('stats-bigram-r').textContent = 'Pearson r = ' + pearsonR(sharedBi.map(x => x.gen), sharedBi.map(x => x.eng)).toFixed(4) + ' (on ' + sharedBi.length + ' shared)';
                $('stats-bigram-legend').innerHTML = legendHtml;

                // Trigram frequency — all generated trigrams
                const trigramCounts = {};
                let totalTrigrams = 0;
                for (const w of words) {
                    const lw = w.toLowerCase();
                    for (let i = 0; i < lw.length - 2; i++) {
                        const tg = lw[i] + lw[i+1] + lw[i+2];
                        if (tg[0] >= 'a' && tg[0] <= 'z' && tg[1] >= 'a' && tg[1] <= 'z' && tg[2] >= 'a' && tg[2] <= 'z') {
                            trigramCounts[tg] = (trigramCounts[tg] || 0) + 1; totalTrigrams++;
                        }
                    }
                }
                const trigramItems = Object.entries(trigramCounts)
                    .map(([tg, c]) => ({ key: tg, label: tg.toUpperCase(), gen: c / totalTrigrams * 100, eng: cmuTrigrams[tg] ?? null }))
                    .sort((a, b) => b.gen - a.gen);
                const sharedTri = trigramItems.filter(x => x.eng !== null);
                if (sharedTri.length > 1) $('stats-trigram-r').textContent = 'Pearson r = ' + pearsonR(sharedTri.map(x => x.gen), sharedTri.map(x => x.eng)).toFixed(4) + ' (on ' + sharedTri.length + ' shared)';
                $('stats-trigram-legend').innerHTML = legendHtml;

                // Phoneme frequency — all generated phonemes
                let phonemeItems = [];
                if (phonemeData) {
                    const phCounts = {};
                    let totalPh = 0;
                    for (const sounds of phonemeData) {
                        for (const raw of sounds) {
                            const s = normalizePhonemeForStats(raw);
                            if (!s) continue;
                            phCounts[s] = (phCounts[s] || 0) + 1;
                            totalPh++;
                        }
                    }
                    phonemeItems = Object.entries(phCounts)
                        .map(([ph, c]) => ({ key: ph, label: ph, gen: c / totalPh * 100, eng: cmuPhonemes[ph] ?? null }))
                        .sort((a, b) => b.gen - a.gen);
                    const sharedPh = phonemeItems.filter(x => x.eng !== null);
                    if (sharedPh.length > 1) $('stats-phoneme-r').textContent = 'Pearson r = ' + pearsonR(sharedPh.map(x => x.gen), sharedPh.map(x => x.eng)).toFixed(4) + ' (on ' + sharedPh.length + ' shared)';
                    const generatedOnlyMass = phonemeItems
                        .filter(x => x.eng === null)
                        .reduce((sum, x) => sum + x.gen, 0);
                    $('stats-phoneme-r').textContent += ' • Non-CMU mass = ' + generatedOnlyMass.toFixed(2) + '%';
                    $('stats-phoneme-legend').innerHTML = legendHtml;
                }

                chartData = { letterItems, bigramItems, trigramItems, phonemeItems };
                rerenderCharts(currentSort);

                // Word length distribution
                const lenCounts = {};
                for (const w of words) { const len = Math.min(w.length, 13); lenCounts[len] = (lenCounts[len] || 0) + 1; }
                const totalWords = words.length;
                const maxLenPct = 30;
                $('stats-length-legend').innerHTML = legendHtml;
                let lenHtml = '';
                for (let i = 1; i <= 13; i++) {
                    const genPct = (lenCounts[i] || 0) / totalWords * 100;
                    const engPct = engLengthDist[i] || 0;
                    const label = i === 13 ? '13+' : String(i);
                    const wG = (genPct / maxLenPct * 100).toFixed(1);
                    const wE = (engPct / maxLenPct * 100).toFixed(1);
                    lenHtml += '<div class="freq-row"><div class="freq-letter" style="width:2.5em">' + label + '</div><div class="freq-bars">' +
                        '<div class="freq-bar" style="width:' + wG + '%;background:steelblue"></div>' +
                        '<div class="freq-bar" style="width:' + wE + '%;background:darkgrey"></div>' +
                        '</div><div class="freq-val">' + genPct.toFixed(1) + ' / ' + engPct.toFixed(1) + '</div></div>';
                }
                $('stats-length-chart').innerHTML = lenHtml;

                // Phoneme length distribution
                if (phonemeData && phonemeData.length > 0) {
                    const phLenCounts = {};
                    for (const sounds of phonemeData) {
                        const len = Math.min(sounds.length, 15);
                        phLenCounts[len] = (phLenCounts[len] || 0) + 1;
                    }
                    const totalPhWords = phonemeData.length;
                    const maxPhLenPct = 30;
                    let phLenHtml = '';
                    for (let i = 1; i <= 15; i++) {
                        const genPct = (phLenCounts[i] || 0) / totalPhWords * 100;
                        const engPct = cmuPhonemeLength[i] || 0;
                        const wG = (genPct / maxPhLenPct * 100).toFixed(1);
                        const wE = (engPct / maxPhLenPct * 100).toFixed(1);
                        const label = i === 15 ? '15+' : String(i);
                        phLenHtml += '<div class="freq-row"><div class="freq-letter" style="width:2.5em">' + label + '</div><div class="freq-bars">' +
                            '<div class="freq-bar" style="width:' + wG + '%;background:steelblue"></div>' +
                            '<div class="freq-bar" style="width:' + wE + '%;background:darkgrey"></div>' +
                            '</div><div class="freq-val">' + genPct.toFixed(1) + ' / ' + engPct.toFixed(1) + '</div></div>';
                    }
                    $('stats-phoneme-length-chart').innerHTML = phLenHtml;
                    $('stats-phoneme-length-legend').innerHTML = legendHtml;
                }
            }

            function initStats() {
                if (statsInited) return;
                statsInited = true;
                runStats();
            }

            $('refresh-stats').addEventListener('click', runStats);

            let currentSort = 'divergence';
            document.querySelectorAll('.sort-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentSort = btn.dataset.sort;
                    document.querySelectorAll('.sort-btn').forEach(b => b.classList.toggle('active', b === btn));
                    rerenderCharts(currentSort);
                });
            });

            // ===== DEBUG TAB =====
            let debugInited = false;
            let debugWord = null;
            let debugTrace = null;
            let debugOptions = null;
            let debugHoverGs = null;
            const debugSelectedGrapheme = new Set();
            const debugSelectedPhoneme = new Set();

            function parseDebugOptions() {
                const seedRaw = parseInt(($('debug-seed')?.value || '42'), 10);
                const seed = Number.isFinite(seedRaw) ? seedRaw : 42;
                const mode = $('debug-mode')?.value === 'text' ? 'text' : 'lexicon';
                const syllableRaw = parseInt(($('debug-syllable-count')?.value || ''), 10);
                const options = { seed, mode, trace: true, morphology: useMorph() };
                if (Number.isFinite(syllableRaw) && syllableRaw >= 1 && syllableRaw <= 7) {
                    options.syllableCount = syllableRaw;
                }
                return options;
            }

            function escapeHtml(str) {
                return (str || '')
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            function setDebugStatus(msg) {
                const el = $('debug-status');
                if (el) el.textContent = msg || '';
            }

            function selectedGsIndices() {
                return Array.from(new Set([...debugSelectedGrapheme, ...debugSelectedPhoneme])).sort((a, b) => a - b);
            }
            function selectedGraphemeIndices() {
                return Array.from(debugSelectedGrapheme).sort((a, b) => a - b);
            }
            function selectedPhonemeIndices() {
                return Array.from(debugSelectedPhoneme).sort((a, b) => a - b);
            }

            function isRepairLinked(gsIndex, repair) {
                const g = debugTrace?.graphemeSelections?.[gsIndex];
                if (!g || !repair) return false;
                const needles = [g.emitted, g.selected].filter(Boolean);
                return needles.some(n => repair.before.includes(n) || repair.after.includes(n));
            }

            function isStructuralLinked(gsIndex, structural) {
                const g = debugTrace?.graphemeSelections?.[gsIndex];
                if (!g || !structural) return false;
                return structural.detail.includes('/' + g.phoneme + '/');
            }

            function toggleDebugSelection(type, gsIndex) {
                const targetSet = type === 'phoneme' ? debugSelectedPhoneme : debugSelectedGrapheme;
                if (targetSet.has(gsIndex)) targetSet.delete(gsIndex);
                else targetSet.add(gsIndex);
            }

            function renderDebug() {
                const wordEl = $('debug-word');
                const ipaEl = $('debug-ipa');
                const graphemeLayerEl = $('debug-grapheme-layer');
                const phonemeLayerEl = $('debug-phoneme-layer');
                const gsTraceEl = $('debug-trace-graphemes');
                const repairsTraceEl = $('debug-trace-repairs');
                const structuralTraceEl = $('debug-trace-structural');
                const stagesTraceEl = $('debug-trace-stages');
                const selectionEl = $('debug-selection');

                if (!debugWord || !debugTrace || !debugTrace.orthography) {
                    wordEl.textContent = 'Generate a traced word to inspect it.';
                    ipaEl.textContent = '';
                    graphemeLayerEl.innerHTML = '';
                    phonemeLayerEl.innerHTML = '';
                    gsTraceEl.innerHTML = '';
                    repairsTraceEl.innerHTML = '';
                    structuralTraceEl.innerHTML = '';
                    stagesTraceEl.innerHTML = '';
                    selectionEl.textContent = '';
                    return;
                }

                const orth = debugTrace.orthography;
                const phonemeUnits = orth.phonemeUnits || orth.graphemeUnits;
                const selectedGs = new Set(selectedGsIndices());
                const hoveredGs = debugHoverGs !== null && debugHoverGs !== undefined && debugHoverGs >= 0
                    ? debugHoverGs
                    : null;

                wordEl.innerHTML = '';
                for (const ch of orth.chars) {
                    const span = document.createElement('span');
                    const isActive = hoveredGs !== null && ch.graphemeSelectionIndex === hoveredGs;
                    const isSelected = selectedGs.has(ch.graphemeSelectionIndex);
                    span.className = 'debug-char' + (isActive ? ' active' : '') + (isSelected ? ' selected' : '');
                    span.textContent = ch.char;
                    span.dataset.gs = String(ch.graphemeSelectionIndex);
                    span.dataset.selType = 'grapheme';
                    wordEl.appendChild(span);
                }
                ipaEl.textContent = debugWord.pronunciation || '';

                const renderUnitLayer = (container, units, type) => {
                    container.innerHTML = '';
                    units.forEach(unit => {
                        const token = document.createElement('span');
                        const isSelected = (type === 'phoneme' ? debugSelectedPhoneme : debugSelectedGrapheme).has(unit.graphemeSelectionIndex);
                        const isActive = hoveredGs !== null && unit.graphemeSelectionIndex === hoveredGs;
                        token.className = 'debug-token' + (isActive ? ' active' : '') + (isSelected ? ' selected' : '');
                        token.dataset.gs = String(unit.graphemeSelectionIndex);
                        token.dataset.selType = type;
                        const unitText = type === 'phoneme'
                            ? ('/' + unit.phoneme + '/')
                            : (unit.emitted && unit.emitted.length > 0 ? unit.emitted : '[empty]');
                        token.textContent = unitText;
                        token.title = '#' + unit.graphemeSelectionIndex + ' ' + unit.position + ' syl:' + unit.syllableIndex;
                        container.appendChild(token);
                    });
                };

                renderUnitLayer(graphemeLayerEl, orth.graphemeUnits, 'grapheme');
                renderUnitLayer(phonemeLayerEl, phonemeUnits, 'phoneme');

                gsTraceEl.innerHTML = debugTrace.graphemeSelections.map(g => {
                    const isSelected = selectedGs.has(g.index);
                    const isActive = hoveredGs !== null && g.index === hoveredGs;
                    const rowClass = 'debug-trace-row' + (isActive ? ' active' : '') + (isSelected ? ' selected' : '');
                    const detail = '#' + g.index + ' /' + g.phoneme + '/ ' + g.position +
                        ' sel=' + g.selected + ' emit=' + (g.emitted || '[empty]') +
                        ' roll=' + g.roll.toFixed(2);
                    return '<div class="' + rowClass + '" data-gs="' + g.index + '" data-sel-type="grapheme">' + escapeHtml(detail) + '</div>';
                }).join('');

                repairsTraceEl.innerHTML = debugTrace.repairs.map((r, idx) => {
                    const linked = hoveredGs !== null && isRepairLinked(hoveredGs, r);
                    const rowClass = linked ? 'debug-trace-row active' : 'debug-trace-row';
                    const detail = '#' + idx + ' ' + r.rule + ' | ' + r.before + ' -> ' + r.after;
                    return '<div class="' + rowClass + '">' + escapeHtml(detail) + '</div>';
                }).join('');

                structuralTraceEl.innerHTML = (debugTrace.structural || []).map((s, idx) => {
                    const linked = hoveredGs !== null && isStructuralLinked(hoveredGs, s);
                    const rowClass = linked ? 'debug-trace-row active' : 'debug-trace-row';
                    const detail = '#' + idx + ' ' + s.event + ' | ' + s.detail;
                    return '<div class="' + rowClass + '">' + escapeHtml(detail) + '</div>';
                }).join('') || '<div class="debug-trace-row">none</div>';

                stagesTraceEl.innerHTML = (debugTrace.stages || []).map((s, idx) => {
                    const detail = '#' + idx + ' ' + s.name + ' (' + s.before.length + '→' + s.after.length + ' syllables)';
                    return '<div class="debug-trace-row">' + escapeHtml(detail) + '</div>';
                }).join('');

                const selectedLines = [];
                for (const gs of Array.from(debugSelectedGrapheme).sort((a, b) => a - b)) {
                    const unit = orth.graphemeUnits.find(u => u.graphemeSelectionIndex === gs);
                    if (unit) selectedLines.push('grapheme #' + gs + ': "' + (unit.emitted || '[empty]') + '" /' + unit.phoneme + '/');
                }
                for (const gs of Array.from(debugSelectedPhoneme).sort((a, b) => a - b)) {
                    const unit = phonemeUnits.find(u => u.graphemeSelectionIndex === gs);
                    if (unit) selectedLines.push('phoneme #' + gs + ': /' + unit.phoneme + '/');
                }
                selectionEl.textContent = selectedLines.length > 0
                    ? ('Selected: ' + selectedGs.size + '\n' + selectedLines.join('\n'))
                    : 'No graphemes/phonemes selected.';
            }

            function generateDebugWord() {
                const options = parseDebugOptions();
                debugWord = unglish.generateWord(options);
                debugTrace = debugWord.trace || null;
                debugOptions = options;
                debugHoverGs = null;
                debugSelectedGrapheme.clear();
                debugSelectedPhoneme.clear();
                renderDebug();
                setDebugStatus('Generated "' + debugWord.written.clean + '" with seed ' + options.seed + '.');
            }

            function adjustDebugSeed(delta) {
                const seedInput = $('debug-seed');
                const curr = parseInt(seedInput.value || '42', 10);
                const next = (Number.isFinite(curr) ? curr : 42) + delta;
                seedInput.value = String(next);
                generateDebugWord();
            }

            function buildDebugPayload() {
                if (!debugWord || !debugTrace || !debugTrace.orthography || !debugOptions) return null;
                const selectedGraphemes = selectedGraphemeIndices();
                const selectedPhonemes = selectedPhonemeIndices();
                const selectedGs = selectedGsIndices();
                const phonemeUnits = debugTrace.orthography.phonemeUnits || debugTrace.orthography.graphemeUnits;
                const selectedGraphemeUnits = debugTrace.orthography.graphemeUnits.filter(u => selectedGraphemes.includes(u.graphemeSelectionIndex));
                const selectedPhonemeUnits = phonemeUnits.filter(u => selectedPhonemes.includes(u.graphemeSelectionIndex));
                const selectedGraphemeSelections = selectedGraphemes
                    .map(i => debugTrace.graphemeSelections[i])
                    .filter(Boolean);
                const selectedPhonemeSelections = selectedPhonemes
                    .map(i => debugTrace.graphemeSelections[i])
                    .filter(Boolean);
                const selectedRepairs = debugTrace.repairs
                    .map((r, index) => ({ index, ...r }))
                    .filter(r => selectedGs.some(gs => isRepairLinked(gs, r)));
                const selectedStructural = (debugTrace.structural || [])
                    .map((s, index) => ({ index, ...s }))
                    .filter(s => selectedGs.some(gs => isStructuralLinked(gs, s)));

                return {
                    schema: 'unglish-debug-report/v1',
                    build: BUILD_INFO,
                    generatedAt: new Date().toISOString(),
                    repro: {
                        seed: debugOptions.seed,
                        mode: debugOptions.mode,
                        morphology: !!debugOptions.morphology,
                        trace: true,
                        syllableCount: debugOptions.syllableCount ?? null,
                    },
                    result: {
                        written: debugWord.written.clean,
                        pronunciation: debugWord.pronunciation,
                        syllableCount: debugWord.syllables.length,
                    },
                    selection: {
                        graphemeSelectionIndices: selectedGraphemes,
                        phonemeSelectionIndices: selectedPhonemes,
                        graphemeUnits: selectedGraphemeUnits,
                        phonemeUnits: selectedPhonemeUnits,
                        graphemeSelections: selectedGraphemeSelections,
                        phonemeSelections: selectedPhonemeSelections,
                        repairs: selectedRepairs,
                        structural: selectedStructural,
                    },
                    comment: ($('debug-comment')?.value || '').trim(),
                };
            }

            function buildDebugMarkdown(payload) {
                const selected = payload.selection.graphemeSelectionIndices.length > 0
                    ? payload.selection.graphemeSelectionIndices.join(', ')
                    : 'none';
                const selectedPh = payload.selection.phonemeSelectionIndices.length > 0
                    ? payload.selection.phonemeSelectionIndices.join(', ')
                    : 'none';
                const comment = payload.comment && payload.comment.length > 0 ? payload.comment : '(none)';
                return [
                    '# Unglish Debug Report',
                    '',
                    '- Word: **' + payload.result.written + '**',
                    '- Pronunciation: `' + payload.result.pronunciation + '`',
                    '- Seed: `' + payload.repro.seed + '`',
                    '- Mode: `' + payload.repro.mode + '`',
                    '- Syllable count (forced): `' + (payload.repro.syllableCount ?? 'auto') + '`',
                    '- Morphology: `' + payload.repro.morphology + '`',
                    '- Selected grapheme indices: `' + selected + '`',
                    '- Selected phoneme indices: `' + selectedPh + '`',
                    '- Comment: ' + comment,
                    '',
                    '```json',
                    JSON.stringify(payload, null, 2),
                    '```',
                ].join('\n');
            }

            async function copyDebugReport() {
                const payload = buildDebugPayload();
                if (!payload) {
                    setDebugStatus('Nothing to copy yet.');
                    return;
                }
                const markdown = buildDebugMarkdown(payload);
                try {
                    await navigator.clipboard.writeText(markdown);
                    setDebugStatus('Copied Markdown + JSON report to clipboard.');
                } catch (err) {
                    setDebugStatus('Clipboard copy failed in this browser context.');
                }
            }

            async function copyDebugRepro() {
                const payload = buildDebugPayload();
                if (!payload) {
                    setDebugStatus('Nothing to copy yet.');
                    return;
                }
                try {
                    await navigator.clipboard.writeText(JSON.stringify(payload.repro, null, 2));
                    setDebugStatus('Copied repro args JSON to clipboard.');
                } catch (err) {
                    setDebugStatus('Clipboard copy failed in this browser context.');
                }
            }

            function initDebug() {
                if (debugInited) return;
                debugInited = true;
                const debugContainers = [
                    'debug-word',
                    'debug-grapheme-layer',
                    'debug-phoneme-layer',
                    'debug-trace-graphemes',
                ];
                const extractSelectableTarget = (event) => {
                    const path = typeof event.composedPath === 'function' ? event.composedPath() : [];
                    for (const node of path) {
                        if (!node || typeof node.getAttribute !== 'function') continue;
                        const gsAttr = node.getAttribute('data-gs');
                        const typeAttr = node.getAttribute('data-sel-type');
                        if (gsAttr !== null && typeAttr !== null) {
                            return { gsAttr, typeAttr };
                        }
                    }
                    const rawTarget = event.target && event.target.nodeType === 3
                        ? event.target.parentElement
                        : event.target;
                    if (rawTarget && typeof rawTarget.closest === 'function') {
                        const el = rawTarget.closest('[data-gs][data-sel-type]');
                        if (el) {
                            return {
                                gsAttr: el.getAttribute('data-gs'),
                                typeAttr: el.getAttribute('data-sel-type'),
                            };
                        }
                    }
                    return null;
                };
                const delegatedSelect = (event) => {
                    const selectedTarget = extractSelectableTarget(event);
                    if (selectedTarget) {
                        const gs = parseInt(selectedTarget.gsAttr || '-1', 10);
                        const selType = selectedTarget.typeAttr;
                        if (!Number.isFinite(gs) || gs < 0) return;
                        if (selType !== 'grapheme' && selType !== 'phoneme') return;
                        event.preventDefault();
                        toggleDebugSelection(selType, gs);
                        setDebugStatus('Selected index #' + gs + ' (' + selType + ').');
                        renderDebug();
                    }
                };
                const delegatedHover = (event) => {
                    const selectedTarget = extractSelectableTarget(event);
                    const gs = selectedTarget ? parseInt(selectedTarget.gsAttr || '-1', 10) : -1;
                    const nextHover = Number.isFinite(gs) && gs >= 0 ? gs : null;
                    if (debugHoverGs !== nextHover) {
                        debugHoverGs = nextHover;
                        renderDebug();
                    }
                };
                const clearHover = () => {
                    if (debugHoverGs !== null) {
                        debugHoverGs = null;
                        renderDebug();
                    }
                };
                debugContainers.forEach(id => {
                    $(id).addEventListener('click', delegatedSelect);
                    $(id).addEventListener('mousemove', delegatedHover);
                    $(id).addEventListener('mouseleave', clearHover);
                });
                $('debug-generate').addEventListener('click', generateDebugWord);
                $('debug-seed-prev').addEventListener('click', () => adjustDebugSeed(-1));
                $('debug-seed-next').addEventListener('click', () => adjustDebugSeed(1));
                $('debug-copy-report').addEventListener('click', copyDebugReport);
                $('debug-copy-repro').addEventListener('click', copyDebugRepro);
                $('debug-mode').addEventListener('change', generateDebugWord);
                $('debug-syllable-count').addEventListener('change', generateDebugWord);
                $('debug-seed').addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter') generateDebugWord();
                });
                generateDebugWord();
            }

            // Hook into tab switching
            document.querySelectorAll('.tab-bar button').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (btn.dataset.tab === 'content-lexicon') initLexicon();
                    if (btn.dataset.tab === 'content-stats') initStats();
                    if (btn.dataset.tab === 'content-debug') initDebug();
                });
            });

            requestAnimationFrame(() => {
                genSingleWord();
                genHaiku();
                genSlogan();
                genSentence();
                genParagraph();
            });
        }
    </script>
</head>
<body>
    <header>
        <h1>Unglish Word Generator</h1>
        <p>English-sounding nonsense, generated by rule</p>
        <p style="font-size: 0.75em; color: var(--muted);" id="build-info">Loading...</p>
    </header>

    <div class="tabs">
        <div class="tab-bar">
            <button disabled data-tab="content-text">Text</button>
            <button data-tab="content-lexicon">Lexicon</button>
            <button data-tab="content-stats">Stats</button>
            <button data-tab="content-debug">Debug</button>
            <label style="margin-left:auto;display:flex;align-items:center;gap:0.3em;font-size:0.9em;cursor:pointer">
                <input type="checkbox" id="morph-toggle" checked> Include affixes
            </label>
        </div>

        <div id="content-text" class="tab-content active">
            <div class="card">
                <h2>Single Word</h2>
                <button class="refresh" id="refresh-single" title="Regenerate">&#x21bb;</button>
                <div class="single-written" id="single-written"></div>
                <div class="pronunciation" id="single-ipa"></div>
                <button class="refresh" id="speak-single" title="Pronounce it" style="right:3em">&#x25B6;</button>
            </div>

            <div class="card">
                <h2>Haiku</h2>
                <button class="refresh" id="refresh-haiku" title="Regenerate">&#x21bb;</button>
                <div class="haiku-written" id="haiku-written"></div>
                <div class="haiku-ipa" id="haiku-ipa"></div>
            </div>

            <div class="card">
                <h2>Slogan</h2>
                <button class="refresh" id="refresh-slogan" title="Regenerate">&#x21bb;</button>
                <div class="slogan-text" id="slogan-text"></div>
            </div>

            <div class="card">
                <h2>Sentence</h2>
                <button class="refresh" id="refresh-sentence" title="Regenerate">&#x21bb;</button>
                <div class="sentence-text" id="sentence-text"></div>
            </div>

            <div class="card">
                <h2>Paragraph</h2>
                <button class="refresh" id="refresh-paragraph" title="Regenerate">&#x21bb;</button>
                <div class="paragraph-text" id="paragraph-text"></div>
                <div class="stat-line" id="paragraph-stats"></div>
            </div>
        </div>

        <div id="content-lexicon" class="tab-content">
            <!-- Word Wall -->
            <div class="card">
                <h2>Word Wall</h2>
                <button class="refresh" id="refresh-wall" title="Regenerate">&#x21bb;</button>
                <div class="word-wall" id="word-wall"></div>
                <div class="legend" id="wall-legend"></div>
            </div>

            <!-- Common Words Race -->
            <div class="card">
                <h2>Common Words Race</h2>
                <p style="font-size:0.85em;color:var(--muted)">How many random words until all 100 most common English words appear?</p>
                <button class="start-btn" id="cw-start">Start Race</button>
                <div id="cw-pills" style="margin-top:0.5em"></div>
                <div class="cw-status" id="cw-status"></div>
            </div>

            <!-- Pick the Real Word -->
            <div class="card">
                <h2>Pick the Real Word</h2>
                <p style="font-size:0.85em;color:var(--muted)">One is real English, one is Unglish. 10 rounds.</p>
                <div class="game-score" id="game-score"></div>
                <div id="game-words"></div>
                <div class="game-actions" id="game-actions"></div>
            </div>
        </div>
        <div id="content-stats" class="tab-content">
            <div style="display:flex;align-items:center;gap:0.5em;margin:0 0 1em 0;font-size:0.9em">
                <span style="color:var(--muted)">Sort:</span>
                <button class="sort-btn active" data-sort="divergence">Deviation</button>
                <button class="sort-btn" data-sort="english">English freq</button>
                <button class="sort-btn" data-sort="unglish">Unglish freq</button>
            </div>
            <div style="display:flex;flex-wrap:wrap;align-items:center;gap:0.7em;margin:0 0 1em 0;font-size:0.85em;color:var(--muted)">
                <label>Sample
                    <input id="stats-sample-size" type="number" min="1000" step="1000" value="200000" style="width:7em;margin-left:0.3em">
                </label>
                <label>Seed start
                    <input id="stats-seed-start" type="number" value="42" style="width:5em;margin-left:0.3em">
                </label>
                <label style="display:flex;align-items:center;gap:0.3em">
                    <input type="checkbox" id="stats-enable-diagnostics"> Diagnostics
                </label>
                <label>Trace sample %
                    <input id="stats-trace-sample" type="number" min="0" max="100" step="1" value="10" style="width:4.5em;margin-left:0.3em">
                </label>
            </div>
            <div class="card">
                <h2>Letter Frequency — Generated vs CMU Dictionary</h2>
                <button class="refresh" id="refresh-stats" title="Regenerate">&#x21bb;</button>
                <div id="stats-status" class="stat-line">Click Regenerate or switch to this tab to generate 200,000 words.</div>
                <div id="stats-diagnostics" class="stat-line"></div>
                <div id="stats-letter-r" style="font-size:1.1em;font-weight:bold;margin:0.5em 0"></div>
                <div class="legend" id="stats-letter-legend"></div>
                <div id="stats-letter-chart"></div>
                <div id="stats-letter-pager"></div>
            </div>

            <div class="card">
                <h2>Bigram Frequency — Generated vs CMU Dictionary</h2>
                <div id="stats-bigram-r" style="font-size:1.1em;font-weight:bold;margin:0.5em 0"></div>
                <div class="legend" id="stats-bigram-legend"></div>
                <div id="stats-bigram-chart"></div>
                <div id="stats-bigram-pager"></div>
            </div>

            <div class="card">
                <h2>Trigram Frequency — Generated vs CMU Dictionary</h2>
                <div id="stats-trigram-r" style="font-size:1.1em;font-weight:bold;margin:0.5em 0"></div>
                <div class="legend" id="stats-trigram-legend"></div>
                <div id="stats-trigram-chart"></div>
                <div id="stats-trigram-pager"></div>
            </div>

            <div class="card">
                <h2>Phoneme Frequency — Generated vs CMU Dictionary</h2>
                <div id="stats-phoneme-r" style="font-size:1.1em;font-weight:bold;margin:0.5em 0"></div>
                <div class="legend" id="stats-phoneme-legend"></div>
                <div id="stats-phoneme-chart"></div>
                <div id="stats-phoneme-pager"></div>
            </div>

            <div class="card">
                <h2>Word Length Distribution — Generated vs CMU Dictionary</h2>
                <div id="stats-length-chart"></div>
                <div class="legend" id="stats-length-legend"></div>
            </div>

            <div class="card">
                <h2>Word Length — Phonemes</h2>
                <div class="legend" id="stats-phoneme-length-legend"></div>
                <div id="stats-phoneme-length-chart"></div>
            </div>
        </div>

        <div id="content-debug" class="tab-content">
            <div class="debug-controls">
                <button id="debug-seed-prev" title="Previous seed">Seed -1</button>
                <label>Seed
                    <input id="debug-seed" type="number" value="42" style="width:6em;margin-left:0.3em">
                </label>
                <button id="debug-seed-next" title="Next seed">Seed +1</button>
                <label>Mode
                    <select id="debug-mode" style="margin-left:0.3em">
                        <option value="lexicon" selected>Lexicon</option>
                        <option value="text">Text</option>
                    </select>
                </label>
                <label>Syllables
                    <input id="debug-syllable-count" type="number" min="1" max="7" placeholder="auto" style="width:4.5em;margin-left:0.3em">
                </label>
                <button id="debug-generate">Generate</button>
            </div>

            <div class="card">
                <h2>Word Inspector</h2>
                <div class="debug-word" id="debug-word"></div>
                <div class="pronunciation" id="debug-ipa"></div>
                <div class="debug-hint">Hover to inspect. Click letters, grapheme/phoneme chips, or grapheme trace rows to select.</div>

                <div class="debug-layer">
                    <div class="debug-layer-title">Graphemes</div>
                    <div id="debug-grapheme-layer"></div>
                </div>

                <div class="debug-layer">
                    <div class="debug-layer-title">Phonemes</div>
                    <div id="debug-phoneme-layer"></div>
                </div>

                <div class="debug-layer">
                    <div class="debug-layer-title">Selected Units</div>
                    <div class="debug-selected" id="debug-selection"></div>
                </div>

                <div class="debug-layer">
                    <div class="debug-layer-title">Comment</div>
                    <textarea id="debug-comment" class="debug-comment" placeholder="What looks wrong? Include what you expected to happen."></textarea>
                    <div class="debug-copy-actions">
                        <button id="debug-copy-report">Copy Report (Markdown + JSON)</button>
                        <button id="debug-copy-repro">Copy Repro Args</button>
                    </div>
                    <div class="debug-status" id="debug-status"></div>
                </div>
            </div>

            <div class="card">
                <h2>Trace View</h2>
                <div class="debug-grid">
                    <div>
                        <div class="debug-layer-title">Grapheme Selections</div>
                        <div id="debug-trace-graphemes" class="debug-trace-list"></div>
                    </div>
                    <div>
                        <div class="debug-layer-title">Repairs</div>
                        <div id="debug-trace-repairs" class="debug-trace-list"></div>
                    </div>
                    <div>
                        <div class="debug-layer-title">Structural</div>
                        <div id="debug-trace-structural" class="debug-trace-list"></div>
                    </div>
                    <div>
                        <div class="debug-layer-title">Stages</div>
                        <div id="debug-trace-stages" class="debug-trace-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
